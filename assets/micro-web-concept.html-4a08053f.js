import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as p,b as i,d as e,e as r,f as a}from"./app-af427ef1.js";const s={},c=a('<div class="hint-container tip"><p class="hint-container-title">前言</p><p>以前只知道微前端的概念，但没有具体的了解过，最近正好因公司需求可以深入微前端。在微前端的架构上了解到有阿里的乾坤，腾讯的无界。本来简单记录介绍下微前端。</p></div><h2 id="微前端是什么" tabindex="-1"><a class="header-anchor" href="#微前端是什么" aria-hidden="true">#</a> 微前端是什么</h2><p>微前端是一个多个团队独立发布功能的方式来共同构建现代化web应用的技术手段及方法策略。<br> 通俗来讲，就是一个<code>web</code>应用中可以独立的运行另一个<code>web</code>应用。</p><p>微前端的应用场景：</p><ul><li>比如制作一个企业管理平台，把已有的采购系统和财务系统统一接入这个平台；</li><li>比如有一个巨大的应用，为了降低开发和维护成本，分拆成多个小应用进行开发和部署，然后用一个平台将这些小应用集成起来；</li><li>又比如一个应用使用vue框架开发，其中有一个比较独立的模块，开发者想尝试使用react框架来开发，等模块单独开发部署完，再把这个模块应用接回去。</li></ul><p>一个完善的微前端框架应该具备哪些能力呢？</p><ul><li>子应用的加载和卸载能力<br> 页面需要从一个子应用切换到另一个子应用，框架必须具备加载、渲染、切换的能力</li><li>子应用独立运行的能力<br> 子应用运行会污染全局的 window 对象，样式会污染其他应用，必须有效的隔离起来</li><li>子应用路由状态保持能力<br> 激活子应用后，浏览器刷新、前进、后退子应用的路由都应该可以正常工作</li><li>应用间通信的能力<br> 应用间可以方便、快捷的通信</li></ul><p>微前端的收益呢？</p><ul><li><p>技术栈无关<br> 主框架不限制接入应用的技术栈，微应用具备完全自主权</p></li><li><p>独立开发、独立部署<br> 微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</p></li><li><p>增量升级<br> 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略</p></li><li><p>独立运行时<br> 每个微应用之间状态隔离，运行时状态不共享</p></li></ul><h2 id="微前端技术有哪些" tabindex="-1"><a class="header-anchor" href="#微前端技术有哪些" aria-hidden="true">#</a> 微前端技术有哪些</h2>',10),d={href:"https://single-spa.js.org/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://wujie-micro.github.io/doc/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://qiankun.umijs.org/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://icestark.gitee.io/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://micro-zoe.github.io/micro-app/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://emp2.netlify.app/",target:"_blank",rel:"noopener noreferrer"},_=a('<h2 id="iframe方案" tabindex="-1"><a class="header-anchor" href="#iframe方案" aria-hidden="true">#</a> iframe方案</h2><p>采用iframe优点：</p><ul><li>非常简单，使用没有任何心智负担</li><li>web应用隔离的非常完美，无论是js、css、dom都完全隔离开来</li></ul><p>采用ifame缺点：</p><ul><li>路由状态丢失，刷新一下，iframe的url状态就丢失了</li><li>dom割裂严重，弹窗只能在iframe内部展示，无法覆盖全局</li><li>web应用之间通信非常困难</li><li>每次打开白屏时间太长，对于SPA 应用来说无法接受</li></ul><h2 id="乾坤方案" tabindex="-1"><a class="header-anchor" href="#乾坤方案" aria-hidden="true">#</a> 乾坤方案</h2><p>qiankun 方案是基于 single-spa 的微前端方案。</p><p>特点：</p><ol><li>html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；</li><li>完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了 strictStyleIsolation、3. 3. 3. experimentalStyleIsolation 两套适用不同场景的方案；</li><li>做了静态资源预加载能力；</li></ol><p>不足：</p><ol><li>适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；</li><li>css 沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；</li><li>无法同时激活多个子应用，也不支持子应用保活；</li><li>无法支持 vite 等 esmodule 脚本运行；</li></ol><p>底层原理 js沙箱使用的是proxy进行快照然后用用 with(window){} 包裹起来 with内的window其实就是proxy.window 我们声明变量 var name = &#39;小满&#39; 实际这个变量挂到了proxy.window 并不是真正的window<br> css沙箱原理 第一个就是shadowDom隔离 第二个类似于Vue的scoped [data-qiankun-426732]</p><h2 id="micro-app-方案" tabindex="-1"><a class="header-anchor" href="#micro-app-方案" aria-hidden="true">#</a> micro-app 方案</h2><p>micro-app 是基于 webcomponent + qiankun sandbox 的微前端方案。</p><p>特点：</p><ol><li>使用 webcomponet 加载子应用相比 single-spa 这种注册监听方案更加优雅；</li><li>复用经过大量项目验证过 qiankun 的沙箱机制也使得框架更加可靠；</li><li>组件式的 api 更加符合使用习惯，支持子应用保活；</li><li>降低子应用改造的成本，提供静态资源预加载能力；</li></ol><p>缺点：</p><ol><li>接入成本较 qiankun 有所降低，但是路由依然存在依赖； （虚拟路由已解决）</li><li>多应用激活后无法保持各子应用的路由状态，刷新后全部丢失； （虚拟路由已解决）</li><li>css 沙箱依然无法绝对的隔离，js 沙箱做全局变量查找缓存，性能有所优化；</li><li>支持 vite 运行，但必须使用 plugin 改造子应用，且 js 代码没办法做沙箱隔离；</li><li>对于不支持 webcompnent 的浏览器没有做降级处理；</li></ol><h2 id="emp方案" tabindex="-1"><a class="header-anchor" href="#emp方案" aria-hidden="true">#</a> EMP方案</h2><p>EMP 方案是基于 webpack 5 module federation 的微前端方案。</p><p>特点：</p><ol><li>webpack 联邦编译可以保证所有子应用依赖解耦；</li><li>应用间去中心化的调用、共享模块；</li><li>模块远程 ts 支持；</li></ol><p>不足:</p><ol><li>对 webpack 强依赖，老旧项目不友好；</li><li>没有有效的 css 沙箱和 js 沙箱，需要靠用户自觉；</li><li>子应用保活、多应用激活无法实现；</li><li>主、子应用的路由可能发生冲突；</li></ol><h2 id="无界微前端方案" tabindex="-1"><a class="header-anchor" href="#无界微前端方案" aria-hidden="true">#</a> 无界微前端方案</h2><p>特点：</p><ol><li>接入简单只需要四五行代码</li><li>不需要针对vite额外处理</li><li>预加载</li><li>应用保活机制</li></ol><p>不足：</p><ol><li>隔离js使用一个空的iframe进行隔离</li><li>子应用axios需要自行适配</li><li>iframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从&#39;about:blank&#39;初始化为主应用的host，这个采用的计时器去等待的不是很优雅。</li></ol>',29);function w(x,k){const l=n("ExternalLinkIcon");return t(),p("div",null,[c,i("p",null,[e("目前微前端技术都是技术基于"),i("a",d,[e("single-spa"),r(l)]),e("的，而国内也已经有人进行对其二次封装。知道的有以下这些：")]),i("ul",null,[i("li",null,[e("腾讯的"),i("a",h,[e("无界"),r(l)])]),i("li",null,[e("阿里的"),i("a",u,[e("乾坤"),r(l)])]),i("li",null,[e("阿里的"),i("a",b,[e("飞冰"),r(l)])]),i("li",null,[i("a",m,[e("MicroApp"),r(l)])]),i("li",null,[i("a",f,[e("EMP"),r(l)])])]),_])}const v=o(s,[["render",w],["__file","micro-web-concept.html.vue"]]);export{v as default};
